---
title: EnsembleLearning
date: 2023-04-23 10:21:01
tags:
- Machine Learnng
categories:
- Machine Learnng
---
多个学习器被训练来解决同一个问题。往往比单个学习器好很多。
一般结构为：先产生一组“个体学习器”，再用某种策略将它们结合起来。集成学习大致可分为三大类：
- Bagging（Bootstrap Aggregating）：有放回的抽样原始数据集，分别训练多个学习器，将多个模型的输出加权平均作为最终结果。e.g. 随机森林
- Boosting：通过在训练新模型实例时更注重先前模型错误分类的实例来增量构建集成模型。e.g. AdaBoost GBDT
- Stacking：训练一个模型用于组合其他各个模型。

# Bagging
## 随机森林
给定
- 数据集 $D\in R^N$ 
- 树数量 $M$，树数量越多，泛化能力越强，但是过大训练速度慢提升也很小。 
- 每棵树所能使用的最大特征数 $k$ 
算法过程：
1. 循环训练$M$个决策树，$\{T_{m}\}^M_{m=1}$
	1. 从数据集 $D\in R^N$ 随机选取$k$个特征得到的子集 $D^\prime_{m} \in R^N$ （显然数据集中可能会有重复的样本） 
	2. 使用$D^\prime_{m}$训练一个决策树$T_{m}$
2. 对于分类任务选择票数最多的（众数），对于回归任务取平均数

我们希望每个弱分类器相关性小，以从不同角度进行判断，增加泛化能力。

# Boosting
## Ada Boost
首先训练一个弱学习器，对于已经能够很好分类的样本，减少这些样本的注意力，后续的弱学习器专注那些分类错的样本，这样训练出一组学习器$f_{m}$，组合在一起，就能对所有类型的样本都有不错的效果。

为了使对不同样本有不同的注意力，我们需要每个样本对应有一个权值$\{w_{1},\dots,w_{n}\}$，被初始化为同一个值$\frac{1}{N}$，，通过将分类器的损失函数乘以样本所对应的权值$L_{m}=\sum^n_{n=1} w_{m}L(y_{n},\hat{y}_{n})$，来达到这样的效果。

训练完一个弱学习器$f_{m}$后，根据其分类误差$L_{m}$计算出一个系数$\alpha_{m}=\frac{1}{2}\log \frac{1-L_{m}}{L_{m}}$，用于更新权值分布与组合学习器，更新权值：$$w_{n}:=\frac{w_{n}}{Z_{n}}\exp(-\alpha_{m} y_{n}\hat{y}_{n})$$其中， $Z_{n}=\sum^N_{i=1}w_{i}\exp(-\alpha_{m}y_{i}\hat{y}_{i})$，用于规范化。

依次训练完一组学习器后，将他们线性组合在一起：
$f(x)=\sum^M_{m=1}\alpha_{m}f_{m}(x)$，最终分类结果$G(x)=\sign(f(x))$
## Gradient Boosting Decision Tree(GBDT)
提升树：每一棵树都是在上一棵树的残差基础上建立的，即真实值是$40$，此时一个弱学习器预测为$20$，残差为$40-20=20$，下一个弱学习器拟合这个残差$20$。

> to be continue...